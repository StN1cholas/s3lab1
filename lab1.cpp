#include <cmath>			// математические функции
#include <locale.h>	// функции, устанавливающие национальные кодировки символов
#include <iostream>	// Эта - часть библиотеки STL (Standard Template Library)
#include <limits>			// Полезные константы
#include <bitset>	// показывает N-ичное представление числа в ограниченном количестве битов
#include <Windows.h>
#include <conio.h>

using namespace std;		// Обеспечивает видимость имен STL
#define stop __asm nop// Эта макроподстановка упрощает установку точек останова

int n;	 // Глобальная переменная. По умолчанию она обнуляется.

namespace space	 // В пространстве имен - space
{
	int n = 1;	 // Объявлена переменная n
}				 // space определяет область видимости этой переменной

int  main()
{	
	// Выполняя программу по шагам, следите за значениями переменных и интерпретируйте результат, объясняя себе
	// наблюдаемые значения. Обратите внимание на разную интерпретацию отладчиком signed и unsigned типов данных.
	char c = 'A'; // 65 'A' 0x41
	// В комментарии справа полезно проставить десятичное символьное и шестнадцатиричное
	// значения переменной после выполнения указанной строки. Вы должны видеть их в окне Autos.
	c = 0x42;		// 66 'B' 0x42
	c = -1;		// -1 'я' 0xff
	c = CHAR_BIT;	 // Размер переменной типа char //8
	stop;

	unsigned char(1024);

	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';
	cout << cw;
	size_t ns = sizeof(cw); // 2 байта

	unsigned char uc = 0x41; // 65 'A' 0x41
	uc = 'B'; // 66 0x42
	uc = -1; // 255 'я'
	stop;

	int i = 1;
	i = -1;
	stop;

	unsigned int ui = 1;
	stop;
	ui = -1; // ui	4294967295	unsigned int
	stop;

	unsigned short s = 0xffff;	 // Здесь compiler генерирует warning. Измените код, чтобы убрать warning
	s = short(0xffff); // 65535
	s = 1;
	stop;

	//for (char test = 125; test < 130; test++)
	//	cout << int(test) << endl;
	/*
		125 // 127 = 01111111
		126		- 128 = 10000000 
		127
		-128
		-2
		..
		-127
		0
		..
	*/

	//==== Измените код, чтобы убрать warning
	unsigned short us = 0xffff;

	cout << char(2048*2 - 1024); // 0

	//for (unsigned char test1 = 253; test1 < 256; test++)
	//	cout << int(test) << endl;
		/*
		253
		254
		255
		0
		1
		2 ..
		*/

	us = short(5);

	stop;

	long l = 0xffffffff;
	l = -128;


	l = FLT_MAX_EXP;	// макс. значение степени экспоненты числа типа float = 128
	l = DBL_MAX_EXP;	// макс. значение степени экспоненты числа типа double = 1024

	l = FLT_MANT_DIG;	// кол-во битов в мантиссе = 24
	l = DBL_DIG;		// кол-во знаков, при которых можно округлить число с плавающей точкой и обратно без потери точности = 15

	l = FLT_MANT_DIG;	// кол-во битов в мантиссе типа float = 24
	l = DBL_MANT_DIG;	// кол-во битов в мантиссе типа double = 53

	float f = -1.256e+1;	 // Здесь warning. Уберите его. ( unsigned float - > float ) 
	stop;
	f = -1.e-27f;
	stop;
	f = FLT_MAX;		// макс. значение числа типа float = 3.402823466e+38F
	f = FLT_MIN;		// мин. положительное число типа float = 1.175494351e-38F

	double d = 0.1234567890123456789123456789;
	d = -0.123456789012345e+306;
	d = DBL_MAX;		// макс. значение типа double = 1.7976931348623158e+308
	d = DBL_MIN;		// мин. значение типа double = 2.2250738585072014e-308
	d = DBL_EPSILON;	// Самая маленькая разность между двумя первыми типа double

	uc = ~0;		 // = 255 Побитовое отрицание
	i = ~0;			 // = -1
	stop;
	// Раннее (при компиляции) или неявное приведение типов данных
	// Объясните те значения, которые вы наблюдаете в окне Autos. Определите порядок выполения присваиваний.
	d = f = i = s = c = 1 / 3; // 1/3 присваивается char и обнуляется, т.к. char целочисленный тип
	stop;
	c = s = i = f = d = 100 / 3; // 100/3 операция между целочисленными типами, поэтому дробь округляется, значение 33 char = '!'
	stop;
	c = s = i = f = d = 10 / 3;  // то же самое, что и выше, во время присваивания double to float, происходит потеря точности плавающей точки в 2 раза
	stop;
	c = s = i = f = d = 1 / 3.;  // 1/3. операция int/double, результат операции double, int во время присваивания округляет значение
	stop;

	// Пример "небрежного" использования неявного приведения типов.	 Объясните результаты.
	i = 256;
	c = i; // 255 макс. число, которое может вместить char, поэтому: 255 + 1 = 0 - "доброта" Ганди

	stop;

	uc = 255;
	unsigned char u = 2, sum = uc + u; // 255 + 2 = 1 т.к. unsigned char от 0 до 255
	stop;

	// Явное приведение типов	Объясните разницу результатов в строках (3) и (4)
	i = 100;
	f = d = i / 3;	// int / int = int						// (3)
	f = d = (double)i / 3; // (double) int / int = (double)int = double		// (4)
	f = d = double(i) / 3; // double(int) / int = double / int = double		// (4)
	f = d = static_cast<double>(i) / 3;		// то же преобразование что и выше, но небезопасное (4)
	stop;

	// Область действия, область видимости и время существования. В этом фрагменте фигурируют четыре
	//  переменных с одним и тем же именем n.  Одна - глобальная, вторая определена в своем пространстве имен,
	// третья - локальная внутри функции main(), четвертая - локальная внутри блока.
	//  Обратите внимание, что глобальная переменная и та, что в пространстве имен space - объявлены вне функции main()
	// Определите, к какой из четырех переменных идет обращение, cформулируйте область действия и область видимости
	// каждой переменной. Для выполнения задания рекомендуется пользоваться  закладкой "Watches" или "Locals" окна
	// "Autos". Подсказка: В окно "Watches" можно поместить сразу все переменные (n, ::n, и space::n)

	n = 100; // глобальная переменная, область действия - вся программа
	space::n = 200; // переменная в пространстве space:: , область действия - вся программа
	n++;	// глобальная переменная
	int n;		//Где живет эта переменная ? В области действия функции main, т.е. пока живет программа - живет эта n
	n = 10;		// в функции main
	::n++;		// глобальная переменная
	stop;
	{				//  Начало блока
		int n;		// Эта переменная живет внутри блока, область действия - блок
		n = -1;
		n++;
		::n++;		// глобальная переменная
		space::n++; // переменная пространства имен space::
	}		// Конец блока
	n--; // переменная функции main
	::n--; // глобальная
	space::n--; // пространства имен space::

	cout << space::n-- - --n; // 191

	// Спецификатор класса памяти - static Выполняя задание по шагам, обратите внимание на  разное поведение
	//	 переменных nLoc и nStat
	{
	Again:
		int outer;
		for (int i = 0; i <= 5; i++)
		{
			static int nStat; // существует в ед. экземпляре, nStat не будет обнуляться при новом заходе в цикл
			{
				int nLoc = 0;
				nLoc++;		nStat++;
			}
			outer = nStat;
		}
		if (outer < 10)//2 // outer = 12
			goto Again;// 1
	}
	//// Перечисления - enum. Обратите внимание на явную и неявную инициализацию констант
	enum RANK
	{
		eSoldier, // 0
		eSergeant, // 1
		eCorporal, // 2
		eLieutenant, // 3
		eCaptain = 6, // 6
		eMajor, // 7
		eColonel = eMajor + 3, // 10
		eGeneral = 20 // 20
	};
	typedef RANK RANG; // RANG становится RANK по определению

	RANG r = eSoldier;
	if (r == eSoldier)
		r = eSergeant;
	 
	if (r == eSergeant)
	{
		// Любой целочисленной переменной можно присвоить enum-переменную
		int i = r;
		r = RANK(i++);		// i++ постинкремент, сначала операция присваивания, а потом увеличивается i++ = 2  // Обратное преобразование надо указывать явно
		i = r;
		r = RANK(++i);		// ++i преинкремент, сначала увеличение на 1, потом операция присваивания
		i = r;		// i = 2, r = 2
		stop;
	}


	RANK rr = eColonel; // rr = 10
	stop; */
	//	Логический тип bool.	Выполняя задание по шагам, следите за значениями переменной b
	{
		int n = 127;
		bool b = n != 0; // b = n != 0 => b = 1 , True
		b = n == 0; // false
		b = n > 0; // true
		b = n <= 0; // false
		b == false; // true

		int num = static_cast<int>(b); // преобразование bool to int, num = 1
		if (b) // if (b) == if (true)
			cout << "\n\t My flag is: true" << "   or: " << b
			<< "\n\t Conversion to int: " << num << endl;
		b = n == num; // b = (n == num) => b = false
		cout << "\n\t Now the flag is: false" << "   or: " << b;
	}

	//	Модификатор const
	const double pi = acos(-1.); // значение арккосинуса(-1) = число Пи
	double space_permiability = 4.e-7 * pi;		//	Магнитная проницаемость пустоты
	const int dozen = 12;
	int var = dozen;
	stop;
	
	


	//	Раскомментируйте следующую строчку и объясните ошибку компиляции (l-value означает left value)

	/*	dozen = 1;  l-value является const, недопустимым для изменения, нельзя присвоить */

	//	Директивы условной трансляции. Объясните значение, которое принимает переменная version.
	//	Что нужно сделать для того, чтобы результат был другим?

	
	// _MSVER$$$ где $$$ номер версии, если 400 то 4.00, если 311, то 3.11
#define _MSVER400 
	const char* version;
#if defined _MSVER400
	version = "version 4.00";
#elif defined _MSVER311
	version = "version 3.11";
#else
	version = "version Unknown"; // если ввести несуществующий номер версии
#endif

	

	cout << endl << version;
	stop;

	//	В окне ClassView или Solution Explorer поставьте фокус на имя проекта дайте команду Project/Properties.
	//	В диалоге Property Pages щелкните на папке Configuration Properties, убедитесь, что в разделе Code Generation
	//	установлена константа компиляции _DEBUG. Создайте директивы препроцессора и код С++, которые
	//	в зависимости от действующей конфигурации проекта (_DEBUG или NDEBUG) выводят соответствующее
	//	сообщение. Измените конфигурацию проекта (в диалоге Property Pages) и проверьте ваш код.
	//	Чтобы изменить конфигурацию пользуйтесь кнопкой Configuration Manager

#if _DEBUG
	printf("_DEBUG");
#elif NDEBUG
	printf("RELEASE")
#else
	printf("UNKNOWN")
#endif


		//	Простейшие циклы. Объясните суть происходящего. 
	{
		// Цикл while надо использовать, когда неизвестно количество итераций (повторений) цикла.
		// Операция & — это побитовое AND.  Операция &= — это побитовое AND с присвоением.
		// Если непонятно, то прочтите документ Операции языка С.doc
		cout << "\n\nGradually eat out all the units:\n\n";
		unsigned short us = 0xff;
		while (us) // пока us != 0 цикл будет выполняться
		{
			cout << hex << us << endl; 
			us &= us - 1; // us = us & (us - 1); выполняется побитовое AND с присваиванием
			// каждый раз единицы заменяются на нули, пока us не обнулится полностью.
			/*
				ff - 0b 1111 1111
				fe - 0b 1111 1110
				fc - 0b 1111 1100
				f8 - 0b 1111 1000
				f0 - 0b 1111 0000
				e0 - 0b 1110 0000
				c0 - 0b 1100 0000
				80 - 0b 1000 0000
				00 - 0b 0000 0000
			*/
		}
		cout << hex << us << "\nDone\n";
		// Цикл for надо использовать, когда известно количество итераций и/или есть код подготовки.
		// Подсказка: odd - нечетое, even - четное.
		cout << "\n\nShow even-odd:\n\n";
		for (int i = 0; i < 10; i++)
		{
			if (i & 1) // сравнивается последний бит числа, четные оканчиваются нулем, нечетные - единицей.
				cout << i << " - odd\n";
			else
				cout << i << " - even\n";
		}
		// Цикл do-while программисты не любят, так как они требуют 
		// большего напряжения при разгадке своей логики.
	/*	 char c = ' ';
		stop;
		do // особенность do-while: первый заход в цикл выполняется в любом случае
		{
			if (c == 'a')
				cout << "\nAction is a delegate type in C#";
			else if (c == 'b')
				cout << "\nbreak is one of the 'leave' statements in all C-like languages";
			else if (c == 'c')
				cout << "\ncontinue is a 'go on' statement in all C-like languages";
			else if (c == 'd')
				cout << "\ndo-while is a rarely used loop statement in all C-like languages";
			else
				cout << "\nPlease read the rules of this loop";
			cout << "\n\nEnter chars: a, b, c, d (q - to quit):\n\n";
			cin >> c;
			if (c == 'q')
				cout << "\nI am going to leave the loop\n";
		} while (c != 'q');
		stop;   */
	}

	

	/*	Логические условные операторы и циклы. Функция y = f(x) задана графиком
		Напишите фрагмент кода, который с шагом 0.1 вычисляет y = f(x)  и выводит в консольное окно значения x и y. 
		  y
		  | 
		 2|__________
		  |         /\
		  |        /  \
		  |       /    \
		  |______/      \__________  x
		  0      1   2   3
		 Реалируйте 2 варианта этого алгоритма:   1. Используйте операторы if	 2. Используйте тернарные операции    ? :*/

	/* {
		for (double i = 0; i <= 4; i += 0.1) {
			if (i <= 1 || i >= 3) std::cout << "x = " << i << "; y = 0 " << endl;
			elif (i <= 2) std::cout << "x = " << i << "; y = " << (2 * i) - 2 << endl;
			else std::cout << "x = " << i << "; y = " << (-2. * i) + 6 << endl;
		}

		for (double(i) = 1; i < 3; i += 0.1) {
			i <= 2 ? std::cout << "x = " << i << "; y = " << 2 * i - 2 << endl : std::cout << "x = " << i << "; y = " << -2 * i + 6 << endl;
		}
	 }
	*/



	/*Напишите фрагмент, который с помощью for и switch реализует следующую логику. Если пользователь ввел:
		символ 'a',   ваш алгоритм выводит  "Ok" (в кавычках)
		символ 'b',   ваш алгоритм выводит  Bell (alert - звуковой сигнал)
		символ 'с',   ваш алгоритм выводит  число, которое равно количеству введенных символов
		символ 'Esc', ваш алгоритм выводит  "to quit use 'q'"
		символ 'q',   ваш алгоритм выводит  "Bye" и выходит из цикла ввода*/


for (char ch = ' '; ch = _getch(); ) {
	static int cnt = 0;
	cnt++;
	switch (ch) {
	case 'a': 
		std::cout << "Ok" << endl;
		break;
	case 'b':
		std::cout << "\a";
		break;
	case 'c':
		std::cout <<"Symbols count: " << cnt << endl;
		break;
	case 27: // esc
		std::cout << "to quit use 'q'" << endl;
		break;
	case 'q':
		std::cout << "Bye" << endl;
		break;
	default:
		std::cout << "Unknown symbol" << endl;
	}
	if (ch == 'q') break;
}

		/*Побитовые операции:  |, &, ~, ^ и сдвиги >>, <<
	//	* | побитовое ИЛИ, результат 1 если хотя бы один из битов операндов 1
	//	* & побитовое И, результат 1 если оба бита операнда 1
	//	* ~ побитовое НЕ, результат обратен биту операнду
	//	* ^ побитовое исключающее ИЛИ, результат 1 только если один из двух битов операндов 1
		Поменяйте местами байты переменной flags и выведите результат в консолное окно unsigned short flags = 0xaabb;
		Ваш код*/
	
	unsigned short flags = 0xaabb;

	flags = ((flags >> 8) & 0x00ff) /* 0x00aa*/ | ((flags << 8) & 0xff00) /*0xbb00 */;
	cout << "\n bits = " << hex << flags; // 0xbbaa
	stop;
	//	Для вывода в шестнадцатеричном виде используйте  cout <<"\n bits = " << hex << flags;
	//	В переменной unsigned char byte = 0x26; установите в единицу 3-й бит (счет от нуля). Выведите результат.
	
	unsigned char byte = 0x26; // 0b 0010 0110	
	cout << "\n bits = " << bitset<8>(byte) << endl;
	byte = byte | 0x10; // 0b 0010 0110 | 0001 0000 = 0b0011 0110
	cout << "\n bits = " << bitset<8>(byte) << endl;
	
	//	Затем инвертируйте два младших бита. Выведите результат. Обнулите 4 младших бита. Выведите результат
	
	byte = byte ^ 0x03; // 0b 0011 0110 ^ 0000 0011 = 0b 0011 0101
	cout << "\n bits = " << bitset<8>(byte) << endl;
	byte = byte & 0xf0; // 0b 0011 0110 & 0b 1111 0000 = 0b 0011 0000
	cout << "\n bits = " << bitset<8>(byte) << endl;
	
	cout << endl << hex << flags << endl << dec << endl << flags << endl;    
	
	int a = 1;
	a = a >> 1 << 1; // 0
	cout << a;

	cout << "\n\n";
	stop;
	

}	// Конец функции main()
